class Solution {
    public boolean isBipartite(int V, int[][] edges) {
        // Code here
        ArrayList<ArrayList<Integer>> adj = getAdj(n,edges);
        boolean[] visited = new boolean[n];
        int[] flag = new int[n];
        Arrays.fill(flag,-1);
        for(int i = 0;i<n;i++){
            if(visited[i] == false){
                flag[i] = 0;
              if(!dfsCycle(i,-1,visited,adj,n,flag)) return false;
            }
        }
        return true;
        
    }
    public static ArrayList<ArrayList<Integer>> getAdj(int n,int[][] edges){
      ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
      for(int i = 0;i<n;i++){
        adj.add(new ArrayList<>());
      }
      for(int i = 0;i<edges.length;i++){
        int u = edges[i][0];
        int v = edges[i][1];
        adj.get(u).add(v);
        adj.get(v).add(u);
      }
      return adj;
    }
    
    public static boolean dfsCycle(int startX,int px,boolean[] visited,ArrayList<ArrayList<Integer>> adj,int n,int[] flag){
      visited[startX] = true;
      for(int nx : adj.get(startX)){
        //   System.out.println(nx);
        if(!visited[nx]){
            flag[nx] = Math.abs(1-flag[startX]);
            // System.out.println(Arrays.toString(flag));
            if(!dfsCycle(nx,startX,visited,adj,n,flag)) return false;
        }
        else{
            // System.out.println(nx +" "+startX);
          if(flag[nx] == flag[startX]) return false;
        //   System.out.println("??");
        }
      }
      return true;
    }
}
